#!/bin/bash

# Function to parse SSL output and save vulnerabilities in a readable text format
parse_ssl_output() {
    local ssl_output_file="$1"
    local vulnerabilities_file="$2"
    local tool_name="$3"
    
    echo "Parsing $tool_name output from $ssl_output_file"
    
    # Define an array of keywords to look for
    local keywords=(
        'vulnerable'
        'insecure'
        'weak'
        'expired'
        'self-signed'
        'untrusted'
        'BEAST'
        'POODLE'
        'vulnerable to Heartbleed'
        'FREAK'
        'Logjam'
        'DROWN'
        'ROBOT'
        'CRIME'
        'BREACH'
        'RC4'
        'SSLv2 enabled'
        'SSLv3 enabled'
        'TLSv1.0 enabled'
        'TLSv1.1 enabled'
        'certificate'
        'cipher'
        'protocol'
        'key exchange'
        'compression'
        'renegotiation supported'
        'forward secrecy'
        'OCSP'
        'HSTS'
        'HPKP'
        'ALPN'
        'NPN'
        'cbc'
    )
    
    # Create a regex pattern from the keywords array, excluding non-vulnerable lines
    local pattern=$(IFS='|'; echo "${keywords[*]}")
    local exclude_pattern='not vulnerable|disabled|does not support|not supported|Unable to parse certificate'
    
    # Extract lines that indicate vulnerabilities and group them
    local vulnerabilities=()
    while IFS= read -r line; do
        vulnerabilities+=("$(echo "$line" | sed 's/^+ //')")
    done < <(grep -E "$pattern" "$ssl_output_file" | grep -Ev "$exclude_pattern")
    
    local url=$(basename "$(dirname "$(dirname "$(dirname "$(dirname "$(dirname "$ssl_output_file")")")")")")
    local port=$(basename "$(dirname "$(dirname "$ssl_output_file")")")
    
    # Output the information in a readable format
    echo "URL: $url" >> "$vulnerabilities_file"
    echo "Port: $port" >> "$vulnerabilities_file"
    echo "Tool: $tool_name" >> "$vulnerabilities_file"
    echo "Vulnerabilities:" >> "$vulnerabilities_file"
    
    if [ ${#vulnerabilities[@]} -gt 0 ]; then
        for vulnerability in "${vulnerabilities[@]}"; do
            echo "  - $vulnerability" >> "$vulnerabilities_file"
        done
    else
        echo "  - No $tool_name vulnerabilities identified" >> "$vulnerabilities_file"
    fi
    
    echo "----------------------------------------" >> "$vulnerabilities_file"
    echo "Vulnerabilities saved to $vulnerabilities_file"
}

# Base directory for the structure
read -p "Enter the client name: " client_name
base_dir="./$client_name/nmap"

# Check if the base directory exists
if [ ! -d "$base_dir" ]; then
    echo "Base directory not found!"
    exit 1
fi

# Create a vulnerabilities directory if it doesn't exist
vulnerabilities_dir="./$client_name/vulnerabilities"
mkdir -p "$vulnerabilities_dir"

# Create a text file for the vulnerabilities report
output_txt="$vulnerabilities_dir/ssl_vulns.txt"
echo "Vulnerabilities Report" > "$output_txt"
echo "======================" >> "$output_txt"

# Iterate over all SSL output files and parse them
for protocol in tcp udp; do
    protocol_dir="$base_dir/$protocol"
    if [ ! -d "$protocol_dir" ]; then
        echo "Protocol directory $protocol_dir not found!"
        continue
    fi

    for url_dir in "$protocol_dir"/*
    do
        if [ -d "$url_dir" ]; then
            url=$(basename "$url_dir")
            for service_dir in "$url_dir/Discovered_Ports"/*
            do
                if [ -d "$service_dir" ]; then
                    for port_dir in "$service_dir"/*
                    do
                        if [ -d "$port_dir" ]; then
                            port=$(basename "$port_dir")
                            
                            # Parse testssl output
                            testssl_dir="$port_dir/testssl"
                            testssl_output_file="$testssl_dir/testssl_output.txt"
                            if [ -f "$testssl_output_file" ]; then
                                parse_ssl_output "$testssl_output_file" "$output_txt" "testssl"
                            else
                                echo "testssl output file $testssl_output_file not found!"
                            fi
                            
                            # Parse sslscan output
                            sslscan_dir="$port_dir/sslscan"
                            sslscan_output_file="$sslscan_dir/sslscan_output.txt"
                            if [ -f "$sslscan_output_file" ]; then
                                parse_ssl_output "$sslscan_output_file" "$output_txt" "sslscan"
                            else
                                echo "sslscan output file $sslscan_output_file not found!"
                            fi
                        fi
                    done
                fi
            done
        fi
    done
done

echo "SSL output parsing completed for all URL:PORT combinations."
echo "Vulnerabilities report saved to $output_txt"