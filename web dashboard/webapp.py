import os
import subprocess
import argparse
import re
import json
import threading
import logging
from concurrent.futures import ThreadPoolExecutor

# Constants
LOG_FILE = 'webapp.log'
LOG_FORMAT = '%(asctime)s - %(levelname)s - %(message)s'
TOOLS = ["nmap", "dirsearch", "whatweb", "nikto", "sslscan", "testssl"]

# Initialize logging
logging.basicConfig(level=logging.INFO, format=LOG_FORMAT)
file_handler = logging.FileHandler(LOG_FILE)
file_handler.setLevel(logging.INFO)
file_handler.setFormatter(logging.Formatter(LOG_FORMAT))
console_handler = logging.StreamHandler()
console_handler.setLevel(logging.INFO)
console_handler.setFormatter(logging.Formatter(LOG_FORMAT))
logging.getLogger().addHandler(file_handler)
logging.getLogger().addHandler(console_handler)

# Progress tracking
progress = {tool: {"total": 0, "completed": 0, "details": []} for tool in TOOLS}

def show_help():
    """Display help message."""
    print("Usage: WebApp.py [-h] ip_list.txt")
    print("\nOptions:")
    print("  -h        Show this help message and exit")
    print("\nArguments:")
    print("  ip_list.txt  Path to the file containing the list of IP addresses")
    print("\nDescription:")
    print("  This tool performs a series of penetration testing scans on a list of IP addresses.")
    print("  It first checks if an Nmap scan has already been completed for each IP address.")
    print("  If the Nmap scan exists, it skips the scan and processes the existing output.")
    print("  The tool then runs additional scans using Dirsearch, WhatWeb, Nikto, SSLscan, and TestSSL.")
    print("  The results of each scan are saved in a structured directory format for easy access and review.")
    print("\nSteps:")
    print("  1. Runs an Nmap scan checking all ports including port 0.")
    print("  2. Creates a folder structure for each service and subsequent ports.")
    print("  3. Runs Dirsearch, Nikto, WhatWeb, SSLscan, and TestSSL scans on the discovered services and ports.")
    print("  4. Parses Nikto output files to extract vulnerabilities and save them in a readable format.")

def run_command(command):
    """Run a shell command and return the output."""
    try:
        logging.info(f"Running command: {command}")
        result = subprocess.run(command, shell=True, check=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        return result.stdout.decode()
    except subprocess.CalledProcessError as e:
        logging.error(f"Command '{command}' failed with error: {e.stderr.decode()}")
        return None

def scan_tool(tool, ip, port, output_dir, command_template):
    """Run a specific tool scan and save the output in both .txt and .json formats."""
    output_txt_file = os.path.join(output_dir, f"{tool}_output.txt")
    output_json_file = os.path.join(output_dir, f"{tool}_output.json")
    command = command_template.format(ip=ip, port=port, output_file=output_txt_file)
    output = run_command(command)
    if output:
        # Save to .txt file
        with open(output_txt_file, 'w') as f:
            f.write(output)
        logging.info(f"{tool.capitalize()} output saved to {output_txt_file}")

        # Save to .json file
        with open(output_json_file, 'w') as f:
            json.dump({"output": output}, f, indent=4)
        logging.info(f"{tool.capitalize()} output saved to {output_json_file}")
    return output_txt_file, output_json_file

def nmap_scan(ip, ip_dir, filename):
    """Perform an Nmap scan if not already done."""
    nmap_output_file = os.path.join(ip_dir, f"output_{filename}.nmap")
    logging.debug(f"Checking if Nmap output file exists: {nmap_output_file}")
    if os.path.isfile(nmap_output_file):
        logging.info(f"Nmap scan for IP: {ip} already exists. Skipping Nmap scan.")
        return False
    command = f"nmap -sS -sC -sV -p0- -vv -oA {os.path.join(ip_dir, f'output_{filename}')} {ip}"
    logging.debug(f"Running Nmap command: {command}")
    run_command(command)
    results = parse_nmap_output(nmap_output_file)
    save_results(results, os.path.join(ip_dir, f"output_{filename}.json"))
    update_progress("nmap", f"Nmap scan completed for IP: {ip}")
    return True

def parse_nmap_output(nmap_output_file):
    """Parse Nmap output to extract open ports and services."""
    results = []
    with open(nmap_output_file, 'r') as f:
        for line in f:
            if 'tcp' in line and 'open' in line:
                port, service = line.split('/')[0], line.split()[2]
                results.append({"port": port, "service": service})
    return results

def process_nmap_output(ip_dir, filename):
    """Process Nmap output to create directories for discovered services and ports."""
    nmap_output_file = os.path.join(ip_dir, f"output_{filename}.nmap")
    discovered_ports_dir = os.path.join(ip_dir, "Discovered_Ports")
    os.makedirs(discovered_ports_dir, exist_ok=True)
    with open(nmap_output_file, 'r') as f:
        for line in f:
            if 'tcp' in line and 'open' in line:
                port, service = line.split('/')[0], line.split()[2]
                service_dir = os.path.join(discovered_ports_dir, service.split('/')[0], port)
                os.makedirs(service_dir, exist_ok=True)
                logging.info(f"Directory created for {service} at {service_dir}")

def run_scans(ip, ip_dir, filename):
    """Run all scans for a given IP address."""
    if nmap_scan(ip, ip_dir, filename):
        process_nmap_output(ip_dir, filename)
    else:
        logging.info(f"Proceeding with other scans for IP: {ip} as Nmap scan already exists.")
    run_tool_scans(ip, ip_dir)

def get_nikto_command(ip, port, service_dir):
    """Determine the correct Nikto command based on the service directory."""
    if 'https' in service_dir.lower() or 'ssl' in service_dir.lower():
        return f"timeout 1m nikto -h https://{ip}:{port} -ssl"
    else:
        return f"timeout 1m nikto -h http://{ip}:{port}"

def run_tool_scans(ip, ip_dir):
    """Run additional tool scans (Dirsearch, WhatWeb, Nikto, SSLscan, TestSSL) on discovered ports."""
    discovered_ports_dir = os.path.join(ip_dir, "Discovered_Ports")
    if not os.path.isdir(discovered_ports_dir):
        logging.warning(f"Discovered ports directory {discovered_ports_dir} not found!")
        return
    for service_dir in os.listdir(discovered_ports_dir):
        service_path = os.path.join(discovered_ports_dir, service_dir)
        if os.path.isdir(service_path):
            for port_dir in os.listdir(service_path):
                port_path = os.path.join(service_path, port_dir)
                if os.path.isdir(port_path):
                    port = port_dir
                    for tool, command_template in [
                        ("dirsearch", "dirsearch -u http://{ip}:{port} -o {output_file}"),
                        ("whatweb", "whatweb -a 3 http://{ip}:{port}"),
                        ("nikto", get_nikto_command(ip, port, service_dir)),
                        ("sslscan", "sslscan {ip}:{port}"),
                        ("testssl", "testssl {ip}:{port}")
                    ]:
                        output_dir = os.path.join(port_path, tool)
                        os.makedirs(output_dir, exist_ok=True)
                        scan_tool(tool, ip, port, output_dir, command_template)
                        update_progress(tool, f"{tool.capitalize()} scan completed for IP: {ip}, Port: {port}")

def update_progress(tool, detail):
    """Update progress tracking for a specific tool."""
    progress[tool]["completed"] += 1
    progress[tool]["details"].append(detail)

def save_results(data, filename):
    """Save scan results to a JSON file."""
    with open(filename, 'w') as f:
        json.dump(data, f, indent=4)

def initialize_progress(ip_list):
    """Initialize progress tracking for all tools."""
    total_ips = len(ip_list)
    for tool in TOOLS:
        progress[tool]["total"] = total_ips

def display_progress():
    """Display progress of scans in real-time."""
    while True:
        user_input = input()
        if user_input.lower() == 'v':
            print("\nCurrent Progress:")
            for tool, data in progress.items():
                print(f"{tool.upper()}: {data['completed']}/{data['total']} completed")
                for detail in data["details"]:
                    print(f"  - {detail}")
            print("\n")

def main():
    """Main function to run the pentest scans."""
    print_banner()
    parser = argparse.ArgumentParser(description="Run pentest scans on a list of IP addresses.")
    parser.add_argument("ip_list", help="Path to the file containing the list of IP addresses")
    parser.print_help = show_help  # Override the default help message
    args = parser.parse_args()

    client_name = input("Enter the client name: ")
    file = args.ip_list

    if not os.path.isfile(file):
        logging.error("File not found!")
        return

    base_dir = os.path.join(".", client_name, "nmap", "tcp")

    with open(file, 'r') as f:
        ip_list = [ip.strip() for ip in f if ip.strip()]
    
    initialize_progress(ip_list)

    # Start the progress display thread
    progress_thread = threading.Thread(target=display_progress)
    progress_thread.daemon = True
    progress_thread.start()

    # Run scans concurrently
    with ThreadPoolExecutor(max_workers=5) as executor:
        for ip in ip_list:
            filename = ip.replace('.', '_')
            ip_dir = os.path.join(base_dir, filename)
            os.makedirs(ip_dir, exist_ok=True)
            executor.submit(run_scans, ip, ip_dir, filename)

    logging.info("All scans (Nmap, Dirsearch, WhatWeb, Nikto, SSLscan, TestSSL) completed for all IP:PORT combinations.")

def print_banner():
    """Print the banner."""
    banner = r"""
 /\_/\  /\_/\  /\_/\  /\_/\  /\_/\  /\_/\  /\_/\  /\_/\  /\_/\  /\_/\  /\_/\  /\_/\  /\_/\  /\_/\  /\_/\  /\_/\  /\_/\  /\_/\  /\_/\  /\_/\  /\_/\  /\_/\  /\_/\ 
( o.o )( o.o )( o.o )( o.o )( o.o )( o.o )( o.o )( o.o )( o.o )( o.o )( o.o )( o.o )( o.o )( o.o )( o.o )( o.o )( o.o )( o.o )( o.o )( o.o )( o.o )( o.o )
 > ^ <  > ^ <  > ^ <  > ^ <  > ^ <  > ^ <  > ^ <  > ^ <  > ^ <  > ^ <  > ^ <  > ^ <  > ^ <  > ^ <  > ^ <  > ^ <  > ^ <  > ^ <  > ^ <  > ^ <  > ^ <  > ^ < 
 /\_/\   .______    _______ .__   __. .___________. _______     _______.___________.   .______    _______   ______   .______    __       _______    /\_/\ 
( o.o )  |   _  \  |   ____||  \ |  | |           ||   ____|   /       |           |   |   _  \  |   ____| /  __  \  |   _  \  |  |     |   ____|  ( o.o )
 > ^ <   |  |_)  | |  |__   |   \|  | `---|  |----`|  |__     |   (----`---|  |----`   |  |_)  | |  |__   |  |  |  | |  |_)  | |  |     |  |__      > ^ < 
 /\_/\   |   ___/  |   __|  |  . `  |     |  |     |   __|     \   \       |  |        |   ___/  |   __|  |  |  |  | |   ___/  |  |     |   __|     /\_/\ 
( o.o )  |  |      |  |____ |  |\   |     |  |     |  |____.----)   |      |  |        |  |      |  |____ |  `--'  | |  |      |  `----.|  |____   ( o.o )
 > ^ <   | _|      |_______||__| \__|     |__|     |_______|_______/       |__|        | _|      |_______| \______/  | _|      |_______||_______|   > ^ < 
 /\_/\  /\_/\  /\_/\  /\_/\  /\_/\  /\_/\  /\_/\  /\_/\  /\_/\  /\_/\  /\_/\  /\_/\  /\_/\  /\_/\  /\_/\  /\_/\  /\_/\  /\_/\  /\_/\  /\_/\  /\_/\  /\_/\ 
( o.o )( o.o )( o.o )( o.o )( o.o )( o.o )( o.o )( o.o )( o.o )( o.o )( o.o )( o.o )( o.o )( o.o )( o.o )( o.o )( o.o )( o.o )( o.o )( o.o )( o.o )
 > ^ <  > ^ <  > ^ <  > ^ <  > ^ <  > ^ <  > ^ <  > ^ <  > ^ <  > ^ <  > ^ <  > ^ <  > ^ <  > ^ <  > ^ <  > ^ <  > ^ <  > ^ <  > ^ <  > ^ <  > ^ <  > ^ <  > ^ <          
 
     /\_/\  /\_/\  /\_/\  /\_/\  /\_/\  /\_/\  /\_/\  /\_/\  /\_/\  /\_/\  /\_/\  /\_/\  /\_/\  /\_/\  /\_/\  /\_/\  /\_/\ 
( o.o )( o.o )( o.o )( o.o )( o.o )( o.o )( o.o )( o.o )( o.o )( o.o )( o.o )( o.o )( o.o )( o.o )( o.o )( o.o )( o.o )( o.o )( o.o )( o.o )( o.o )
 > ^ <  > ^ <  > ^ <  > ^ <  > ^ <  > ^ <  > ^ <  > ^ <  > ^ <  > ^ <  > ^ <  > ^ <  > ^ <  > ^ <  > ^ <  > ^ <  > ^ <  > ^ <  > ^ <  > ^ < 
 /\_/\   ____    __    ____  _______ .______           ___      .______   .______      .___________.  ______     ______    __         /\_/\ 
( o.o )  \   \  /  \  /   / |   ____||   _  \         /   \     |   _  \  |   _  \     |           | /  __  \   /  __  \  |  |       ( o.o )
 > ^ <    \   \/    \/   /  |  |__   |  |_)  |       /  ^  \    |  |_)  | |  |_)  |    `---|  |----`|  |  |  | |  |  |  | |  |        > ^ < 
 /\_/\     \            /   |   __|  |   _  <       /  /_\  \   |   ___/  |   ___/         |  |     |  |  |  | |  |  |  | |  |        /\_/\ 
( o.o )     \    /\    /    |  |____ |  |_)  |     /  _____  \  |  |      |  |             |  |     |  `--'  | |  `--'  | |  `----.  ( o.o )
 > ^ <       \__/  \__/     |_______||______/     /__/     \__\ | _|      | _|             |__|      \______/   \______/  |_______|   > ^ < 
 /\_/\  /\_/\  /\_/\  /\_/\  /\_/\  /\_/\  /\_/\  /\_/\  /\_/\  /\_/\  /\_/\  /\_/\  /\_/\  /\_/\  /\_/\  /\_/\  /\_/\  /\_/\  /\_/\  /\_/\  /\_/\  /\_/\ 
( o.o )( o.o )( o.o )( o.o )( o.o )( o.o )( o.o )( o.o )( o.o )( o.o )( o.o )( o.o )( o.o )( o.o )( o.o )( o.o )( o.o )( o.o )( o.o )( o.o )( o.o )
 > ^ <  > ^ <  > ^ <  > ^ <  > ^ <  > ^ <  > ^ <  > ^ <  > ^ <  > ^ <  > ^ <  > ^ <  > ^ <  > ^ <  > ^ <  > ^ <  > ^ <  > ^ <  > ^ <  > ^ <  > ^ <  > ^ <  > ^ < 
    """
    print(f"\033[92m{banner}\033[0m")

if __name__ == "__main__":
    main()
